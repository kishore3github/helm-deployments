# .github/workflows/main.yaml
name: Consolidated Deployment Workflow

on:
  push:
    branches:
      - main
    paths:
      - 'consolidated-deployments.yaml'
  workflow_dispatch:
    inputs:
      mode:
        description: 'Mode of operation'
        required: true
        default: 'sequential'
        type: choice
        options:
          - sequential
          - parallel

jobs:
  read-services:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install yq and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          sudo snap install yq

      - name: Read deployment.yaml and deploy sequentially
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          DRY_RUN: false
        run: |
            echo "GH_TOKEN: ${GH_TOKEN:-(not set)}"
            echo "GITHUB_REF_NAME: ${GITHUB_REF_NAME:-(not set)}"
            DRY_RUN="${{ env.DRY_RUN }}"
            echo "Reading services from consolidated-deployments.yaml"
            i=0

            yq -o=json '.deployments' consolidated-deployments.yaml | jq -c '.[]' | while read -r serviceGroup; do
              echo "=== Deploying group $i in parallel ==="
              run_ids_file="run_ids_$i.txt"
              > "$run_ids_file"

              mapfile -t services < <(echo "$serviceGroup" | jq -c '.[]')

              pids=()
              for svc in "${services[@]}"; do
                name=$(echo "$svc" | jq -r '.name')
                ns=$(echo "$svc" | jq -r '.namespace')
                image=$(echo "$svc" | jq -r '.image')
                flyway=$(echo "$svc" | jq -r '.flyway')

                echo "Triggering $name in namespace $ns with image $image and flyway=$flyway"
                unique_id=$(date +%s%N)
                trigger_id="$unique_id"

                (
                  echo "Triggering workflow for $name with inputs:"
                  echo "  Namespace: $ns"
                  echo "  Image: $image"
                  echo "  Flyway: $flyway"
                  echo "  Trigger ID: $trigger_id"

                  if [[ "$DRY_RUN" == "true" ]]; then
                    echo "üß™ Dry-run mode: Simulating workflow trigger for $name"
                    simulated_run_id="dryrun-${name}-${ns}-${unique_id}"
                    echo "$simulated_run_id" >> "$run_ids_file"
                    exit 0
                  fi

                  echo "üîÑ Running gh workflow for $name in $ns..."
                  
                  run_output=$(gh workflow run reusable_cd.yaml \
                    -f service="$name" \
                    -f image_tag="$image" \
                    -f namespace="$ns" \
                    -f flyway="$flyway" \
                    -f trigger_id="$trigger_id" \
                    --json id 2>&1)
                  exit_code=$?

                  echo "üîç gh workflow run exit code: $exit_code"
                  echo "üìÑ gh workflow run output:"
                  echo "$run_output"

                  if [[ $exit_code -ne 0 ]]; then
                    echo "‚ùå gh workflow run failed for $name in $ns"
                    exit 1
                  fi



                  echo "Run output: $run_output"
                  new_run_id=$(echo "$run_output" | jq -r '.id // empty')

                  if [[ -z "$new_run_id" ]]; then
                    echo "‚ö†Ô∏è Direct run ID capture failed for $name. Polling for run ID..."
                    for attempt in {1..12}; do
                      sleep 5
                      new_run_id=$(gh run list --workflow=reusable_cd.yaml --branch="${GITHUB_REF_NAME:-main}" --json databaseId,headBranch,headSha,createdAt,displayTitle \
                        | jq -r --arg name "$name" --arg ns "$ns" --arg id "$trigger_id" '
                          map(select(.displayTitle | test($name) and test($ns)))
                          | sort_by(.createdAt)
                          | reverse
                          | .[0].databaseId // empty')

                      if [[ -n "$new_run_id" ]]; then
                        echo "‚úÖ Found run ID via polling: $new_run_id"
                        break
                      fi
                    done
                  fi

                  if [[ -z "$new_run_id" ]]; then
                    echo "‚ùå Failed to get new run ID for $name"
                    exit 1
                  fi

                  echo "Run ID for $name in $ns: $new_run_id"
                  echo "$new_run_id" >> "$run_ids_file"
                ) &
                pids+=($!)
              done

              for pid in "${pids[@]}"; do
                wait "$pid"
              done

              watch_pids=()
              while read -r id; do
                (
                  if [[ "$DRY_RUN" == "true" ]]; then
                    echo "üß™ Dry-run mode: Simulating watch for $id"
                    echo "‚úÖ Simulated run $id succeeded"
                    exit 0
                  fi

                  while true; do
                    status=$(gh run view "$id" --json status -q '.status')
                    conclusion=$(gh run view "$id" --json conclusion -q '.conclusion')
                    echo "Workflow $id status: $status / $conclusion"

                    if [[ "$status" == "completed" ]]; then
                      if [[ "$conclusion" == "success" ]]; then
                        echo "‚úÖ Run $id succeeded"
                        break
                      else
                        echo "‚ùå Run $id failed or cancelled"
                        exit 1
                      fi
                    fi
                    sleep 10
                  done
                ) &
                watch_pids+=($!)
              done < "$run_ids_file"

              for pid in "${watch_pids[@]}"; do
                wait "$pid"
              done
              rm -f "$run_ids_file"
              echo "‚úÖ Group $i complete"
              ((i+=1))
            done
